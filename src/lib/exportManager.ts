/**
 * Export Manager - Export PRDs and responses in various formats
 */

import type { PRDDocument, ResponseSet } from './types';

/**
 * Export PRD as Markdown
 */
export function exportPRDAsMarkdown(prd: PRDDocument): string {
    let markdown = `# ${prd.title}\n\n`;
    markdown += `_Generated on ${formatDate(prd.createdAt)}_\n\n`;
    markdown += `---\n\n`;

    // Sort sections by order
    const sortedSections = [...prd.sections].sort((a, b) => a.order - b.order);

    for (const section of sortedSections) {
        markdown += `## ${section.title}\n\n`;
        markdown += `${section.content}\n\n`;

        if (section.sourceModels.length > 0) {
            markdown += `_Sources: ${section.sourceModels.map(formatPlatformName).join(', ')}_\n\n`;
        }
    }

    markdown += `---\n\n`;
    markdown += `_Generated by Multi-LLM PRD Writer_\n`;

    return markdown;
}

/**
 * Export full session (prompts + responses)
 */
export function exportFullSession(
    title: string,
    responseSets: ResponseSet[]
): string {
    let markdown = `# Session Export: ${title}\n\n`;
    markdown += `_Exported on ${formatDate(Date.now())}_\n\n`;

    for (const rs of responseSets) {
        markdown += `---\n\n`;
        markdown += `## Stage: ${formatStageName(rs.stage)}\n\n`;
        markdown += `_Created: ${formatDate(rs.createdAt)}_\n\n`;

        if (rs.prompt) {
            markdown += `### Prompt\n\n\`\`\`\n${rs.prompt}\n\`\`\`\n\n`;
        }

        markdown += `### Responses\n\n`;

        for (const [platform, response] of Object.entries(rs.responses)) {
            if (response) {
                markdown += `#### ${formatPlatformName(platform)}\n\n`;
                markdown += `_${response.wordCount} words | Captured ${formatDate(response.capturedAt)}_\n\n`;
                markdown += `${response.text}\n\n`;
            }
        }
    }

    return markdown;
}

/**
 * Copy PRD to clipboard as formatted text
 */
export async function copyPRDToClipboard(prd: PRDDocument): Promise<boolean> {
    const markdown = exportPRDAsMarkdown(prd);

    try {
        await navigator.clipboard.writeText(markdown);
        return true;
    } catch (error) {
        console.error('[ExportManager] Failed to copy to clipboard:', error);
        return false;
    }
}

/**
 * Download PRD as file
 */
export function downloadPRDAsFile(prd: PRDDocument): void {
    const markdown = exportPRDAsMarkdown(prd);
    const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const sanitizedTitle = prd.title.replace(/[^a-zA-Z0-9-_]/g, '_').substring(0, 50);
    const filename = `${sanitizedTitle}_PRD_${formatDateShort(prd.createdAt)}.md`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
}

/**
 * Download session export as file
 */
export function downloadSessionAsFile(title: string, responseSets: ResponseSet[]): void {
    const markdown = exportFullSession(title, responseSets);
    const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const sanitizedTitle = title.replace(/[^a-zA-Z0-9-_]/g, '_').substring(0, 50);
    const filename = `${sanitizedTitle}_Session_${formatDateShort(Date.now())}.md`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    URL.revokeObjectURL(url);
}

/**
 * Export section as formatted text
 */
export function exportSectionAsText(sectionTitle: string, content: string): string {
    return `## ${sectionTitle}\n\n${content}`;
}

/**
 * Copy section to clipboard
 */
export async function copySectionToClipboard(sectionTitle: string, content: string): Promise<boolean> {
    const text = exportSectionAsText(sectionTitle, content);

    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch (error) {
        console.error('[ExportManager] Failed to copy section:', error);
        return false;
    }
}

// Helper functions

function formatDate(timestamp: number): string {
    return new Date(timestamp).toLocaleString();
}

function formatDateShort(timestamp: number): string {
    const d = new Date(timestamp);
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
}

function formatPlatformName(platform: string): string {
    const names: Record<string, string> = {
        'chatgpt': 'ChatGPT',
        'claude': 'Claude',
        'gemini': 'Gemini',
        'grok': 'Grok'
    };
    return names[platform] || platform;
}

function formatStageName(stage: string): string {
    const names: Record<string, string> = {
        'idle': 'Idle',
        'stage1_briefing': 'Stage 1: Briefing',
        'stage2_research': 'Stage 2: Research',
        'stage3_synthesis': 'Stage 3: Synthesis'
    };
    return names[stage] || stage;
}
